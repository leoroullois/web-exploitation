import * as bcrypt from 'bcryptjs';
import Joi from 'joi';
import * as jwt from 'jsonwebtoken';
import { extendType, nonNull, objectType, stringArg } from 'nexus';

import { APP_SECRET } from '../utils/auth';
import { authSchema } from '../validators/auth-schema';

export const AuthPayload = objectType({
  name: "AuthPayload",
  definition(t) {
    t.string("token");
    t.field("user", {
      type: "User",
    });
  },
});

export const AuthMutation = extendType({
  type: "Mutation",
  definition(t) {
    t.nonNull.field("signup", {
      type: "AuthPayload",
      args: {
        name: nonNull(stringArg()),
        email: nonNull(stringArg()),
        password: nonNull(stringArg()),
      },
      async resolve(parent, args, ctx, info) {
        try {
          const valid = await authSchema.validateAsync(args);
        } catch (err) {
          console.log("err, ", err);
          throw new Error(JSON.stringify(err));
        }
        const { name, email } = args;
        const password = await bcrypt.hash(args.password, 10);
        const user = await ctx.prisma.user.create({
          data: {
            name,
            email,
            password,
          },
        });
        const token = jwt.sign({ userId: user.id }, APP_SECRET);

        ctx.res.cookie("token", token, {
          httpOnly: true,
          secure: false,
          sameSite: "strict",
        });

        return {
          token,
          user,
        };
      },
    });
    t.nonNull.field("login", {
      type: "AuthPayload",
      args: {
        email: nonNull(stringArg()),
        password: nonNull(stringArg()),
      },
      async resolve(parent, args, ctx, info) {
        const user = await ctx.prisma.user.findUnique({
          where: { email: args.email },
        });
        if (!user) {
          throw new Error("No user found");
        }

        const valid = await bcrypt.compare(args.password, user.password);
        if (!valid) {
          throw new Error("Invalid password");
        }
        const token = jwt.sign({ userId: user.id }, APP_SECRET);

        ctx.res.cookie("token", token, {
          httpOnly: true,
          secure: false,
          sameSite: "strict",
        });


        return {
          token,
          user,
        };
      },
    });

    t.nonNull.field("logout", {
      type: "AuthPayload",
      resolve(parent, args, ctx, info) {
        console.log("log out");

        if (ctx.userId) {
          ctx.res.clearCookie("token");
        }

        return {
          token: null,
          user: null,
        };
      },
    });
  },
});

